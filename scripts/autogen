#!/usr/bin/env python3
# Copyright (c) 2024-2025 The mldsa-native project authors
# Copyright (c) 2025      The mldsa-native project authors
# SPDX-License-Identifier: Apache-2.0

import subprocess
import platform
import argparse
import pathlib
import sys
import os

from concurrent.futures import ThreadPoolExecutor
from functools import partial

modulus = 8380417
root_of_unity = 1753
montgomery_factor = pow(2, 32, modulus)

# This file re-generated auto-generated source files in mldsa-native.
#
# It currently covers:
# - zeta values for the reference NTT and invNTT
# - header guards


def status_update(task, msg):
    print(f"\r{'':<140}", end="", flush=True)
    print(f"\r[{task}]: {msg} ...", end="", flush=True)


def gen_header():
    yield "/*"
    yield " * Copyright (c) 2024-2025 The mldsa-native project authors"
    yield " * SPDX-License-Identifier: Apache-2.0"
    yield " */"
    yield ""
    yield "/*"
    yield " * WARNING: This file is auto-generated from scripts/autogen"
    yield " *          Do not modify it directly."
    yield " */"
    yield ""


def get_files(pattern):
    return [str(p) for p in pathlib.Path().glob(pattern) if p.is_file()]


def get_c_source_files():
    return get_files("mldsa/**/*.c")


def get_header_files():
    return get_files("mldsa/**/*.h")


def format_content(content):
    p = subprocess.run(
        ["clang-format"], capture_output=True, input=content, text=True, shell=True
    )
    if p.returncode != 0:
        print(p.stderr)
        print(
            f"Failed to auto-format autogenerated code (clang-format return code {p.returncode}). Are you running in a nix shell? See BUILDING.md."
        )
        exit(1)
    return p.stdout


def update_file(filename, content, dry_run=False, force_format=False):

    if force_format is True or filename.endswith((".c", ".h", ".i")):
        content = format_content(content)

    if dry_run is False:
        with open(filename, "w+") as f:
            f.write(content)
    else:
        if os.path.exists(filename) is False:
            print(f"Autogenerated file {filename} does not exist")
            exit(1)
        with open(filename, "r") as f:
            current_content = f.read()
        if current_content != content:
            filename_new = f"{filename}.new"
            print(
                f"Autogenerated file {filename} needs updating. Have you called scripts/autogen?",
                file=sys.stderr,
            )
            print(f"Writing new version to {filename_new}", file=sys.stderr)
            with open(filename_new, "w") as f:
                f.write(content)
            subprocess.run(["diff", filename, filename_new])
            exit(1)


def bitreverse(i, n):
    r = 0
    for _ in range(n):
        r = 2 * r + (i & 1)
        i >>= 1
    return r


def signed_reduce(a):
    """Return signed canonical representative of a mod b"""
    c = a % modulus
    if c >= modulus / 2:
        c -= modulus
    return c


def gen_c_zetas():
    """Generate source and header file for zeta values used in
    the reference NTT and invNTT"""

    # The zeta values are the powers of the chosen root of unity (17),
    # converted to Montgomery form.

    zeta = [0]  # First entry is unused and set to 0
    for i in range(1, 256):
        zeta.append(signed_reduce(pow(root_of_unity, i, modulus) * montgomery_factor))

    # The source code stores the zeta table in bit reversed form
    yield from (zeta[bitreverse(i, 8)] for i in range(256))


def gen_c_zeta_file(dry_run=False):
    def gen():
        yield from gen_header()
        yield "#include <stdint.h>"
        yield ""
        yield "/*"
        yield " * Table of zeta values used in the reference NTT and inverse NTT."
        yield " * See autogen for details."
        yield " */"
        yield "static const int32_t zetas[MLDSA_N] = {"
        yield from map(lambda t: str(t) + ",", gen_c_zetas())
        yield "};"
        yield ""

    update_file("mldsa/zetas.inc", "\n".join(gen()), dry_run=dry_run, force_format=True)


def adjust_header_guard_for_filename(content, header_file):

    status_update("header guards", header_file)

    content = content.split("\n")
    exceptions = {}

    # Use full filename as the header guard, with '/' and '.' replaced by '_'
    guard_name = (
        header_file.removeprefix("mldsa/").replace("/", "_").replace(".", "_").upper()
    )
    guard_name = "MLD_" + guard_name

    if header_file in exceptions.keys():
        guard_name = exceptions[header_file]

    def gen_copyright():
        yield "/*"
        yield " * Copyright (c) 2025 The mldsa-native project authors"
        yield " * SPDX-License-Identifier: Apache-2.0"
        yield " */"

    def gen_guard():
        yield f"#ifndef {guard_name}"
        yield f"#define {guard_name}"

    def gen_footer():
        yield f"#endif"
        yield ""

    cr = list(gen_copyright())
    guard = list(gen_guard())
    footer = list(gen_footer())

    # Check if header file begins with copyright notice; otherwise, add it.
    if content[: len(cr)] != cr:
        assert False
        content = cr + content
    i = len(cr)
    while content[i].strip() == "":
        i += 1
    # Check if header file has some guard -- if so, drop it
    if content[i].strip().startswith("#if !defined") or content[i].strip().startswith(
        "#ifndef"
    ):
        del content[i]
        if content[i].strip().startswith("#define"):
            del content[i]
        has_guard = True
    else:
        has_guard = False
    # Add standardized guard
    content = content[:i] + guard + content[i:]
    # Check if header has some footer
    if (
        has_guard is True
        and content[-1] == ""
        and content[-2].strip().startswith("#endif")
    ):
        del content[-2:]
    # Add standardized footer
    content = content + footer

    return "\n".join(content)


def gen_header_guard(header_file, dry_run=False):
    with open(header_file, "r") as f:
        content = f.read()
    new_content = adjust_header_guard_for_filename(content, header_file)
    update_file(header_file, new_content, dry_run=dry_run)


def gen_header_guards(dry_run=False):
    with ThreadPoolExecutor() as executor:
        _ = list(
            executor.map(partial(gen_header_guard, dry_run=dry_run), get_header_files())
        )


def _main():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument("--dry-run", default=False, action="store_true")

    args = parser.parse_args()

    os.chdir(os.path.join(os.path.dirname(__file__), ".."))

    gen_c_zeta_file(args.dry_run)
    gen_header_guards(args.dry_run)

    print()


if __name__ == "__main__":
    _main()
